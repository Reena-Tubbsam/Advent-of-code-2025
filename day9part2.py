data = """
# paste your full input here, one "x,y" per line (no extra text)

98004,50283
98004,51502
98073,51502
98073,52727
98144,52727
98144,53937
97953,53937
97953,55168
98003,55168
98003,56406
98033,56406
98033,57473
96926,57473
96926,58748
97199,58748
97199,59926
96895,59926
96895,61220
97084,61220
97084,62314
96426,62314
96426,63395
95789,63395
95789,64490
95244,64490
95244,65829
95432,65829
95432,66934
94907,66934
94907,68050
94423,68050
94423,69341
94345,69341
94345,70156
93192,70156
93192,71485
93153,71485
93153,72568
92590,72568
92590,73702
92113,73702
92113,74741
91467,74741
91467,75567
90483,75567
90483,76688
89978,76688
89978,77537
89068,77537
89068,78372
88163,78372
88163,79469
87609,79469
87609,80612
87093,80612
87093,81578
86346,81578
86346,82422
85463,82422
85463,82939
84244,82939
84244,84206
83804,84206
83804,84848
82735,84848
82735,85434
81634,85434
81634,86745
81168,86745
81168,87730
80395,87730
80395,87950
79018,87950
79018,88564
77968,88564
77968,89681
77272,89681
77272,90032
76045,90032
76045,90883
75148,90883
75148,91125
73882,91125
73882,91934
72952,91934
72952,92557
71910,92557
71910,92993
70774,92993
70774,93784
69804,93784
69804,94065
68601,94065
68601,94737
67564,94737
67564,94644
66234,94644
66234,95260
65172,95260
65172,96308
64228,96308
64228,96569
63027,96569
63027,96815
61826,96815
61826,96343
60465,96343
60465,96835
59336,96835
59336,97723
58262,97723
58262,97006
56916,97006
56916,97227
55731,97227
55731,97435
54540,97435
54540,98266
53388,98266
53388,98391
52167,98391
52167,98195
50936,98195
50936,98172
49715,98172
49715,97959
48500,97959
48500,98135
47273,98135
47273,98219
46040,98219
46040,97295
44907,97295
44907,97942
43605,97942
43605,96967
42520,96967
42520,96937
41300,96937
41300,96652
40124,96652
40124,96994
38801,96994
38801,96419
37687,96419
37687,95965
36552,95965
36552,95897
35300,95897
35300,95312
34211,95312
34211,94929
33056,94929
33056,94007
32118,94007
32118,93804
30894,93804
30894,93729
29593,93729
29593,93046
28568,93046
28568,92453
27503,92453
27503,91601
26586,91601
26586,90840
25632,90840
25632,90635
24336,90635
24336,89546
23599,89546
23599,89479
22173,89479
22173,88691
21234,88691
21234,87455
20651,87455
20651,87191
19306,87191
19306,86273
18485,86273
18485,85089
17918,85089
17918,84736
16587,84736
16587,83568
16032,83568
16032,83102
14760,83102
14760,82116
14026,82116
14026,81313
13084,81313
13084,79817
12987,79817
12987,79115
11922,79115
11922,78148
11187,78148
11187,77151
10493,77151
10493,75950
10112,75950
10112,74905
9511,74905
9511,74201
8326,74201
8326,72904
8152,72904
8152,71838
7581,71838
7581,70676
7210,70676
7210,69798
6230,69798
6230,68607
5921,68607
5921,67692
4935,67692
4935,66370
4983,66370
4983,65240
4534,65240
4534,64208
3759,64208
3759,62870
3992,62870
3992,61715
3622,61715
3622,60663
2780,60663
2780,59343
3127,59343
3127,58209
2581,58209
2581,57040
2155,57040
2155,55761
2518,55761
2518,54592
2022,54592
2022,53344
2362,53344
2362,52146
2079,52146
2079,50925
2365,50925
2365,50265
94901,50265
94901,48488
1659,48488
1659,47308
2494,47308
2494,46043
1812,46043
1812,44875
2401,44875
2401,43591
1950,43591
1950,42377
2134,42377
2134,41191
2472,41191
2472,40153
3483,40153
3483,38963
3684,38963
3684,37617
3317,37617
3317,36454
3697,36454
3697,35377
4342,35377
4342,34263
4837,34263
4837,32955
4800,32955
4800,31869
5379,31869
5379,30923
6262,30923
6262,29782
6675,29782
6675,28650
7119,28650
7119,27415
7379,27415
7379,26415
8095,26415
8095,25406
8781,25406
8781,24145
9061,24145
9061,23300
10005,23300
10005,22154
10494,22154
10494,21597
11796,21597
11796,20131
11881,20131
11881,19735
13328,19735
13328,18722
13998,18722
13998,17795
14776,17795
14776,16811
15496,16811
15496,15841
16243,15841
16243,14681
16822,14681
16822,14162
18004,14162
18004,13340
18903,13340
18903,12715
19963,12715
19963,11815
20802,11815
20802,11108
21793,11108
21793,10828
23078,10828
23078,10062
24016,10062
24016,9070
24823,9070
24823,8392
25837,8392
25837,7547
26764,7547
26764,7731
28238,7731
28238,6379
28922,6379
28922,5921
30062,5921
30062,5661
31282,5661
31282,5137
32386,5137
32386,5118
33678,5118
33678,4277
34673,4277
34673,4403
35989,4403
35989,4090
37156,4090
37156,3656
38292,3656
38292,3559
39512,3559
39512,2594
40549,2594
40549,2472
41771,2472
41771,2323
42984,2323
42984,2689
44258,2689
44258,2443
45448,2443
45448,2139
46639,2139
46639,1555
47830,1555
47830,1845
49064,1845
49064,1634
50286,1634
50286,2188
51494,2188
51494,2386
52697,2386
52697,2595
53892,2595
53892,2621
55101,2621
55101,2661
56313,2661
56313,2728
57528,2728
57528,2364
58828,2364
58828,2818
59987,2818
59987,2845
61236,2845
61236,3836
62244,3836
62244,3791
63518,3791
63518,4250
64651,4250
64651,4284
65928,4284
65928,5346
66839,5346
66839,5849
67939,5849
67939,5650
69343,5650
69343,6127
70473,6127
70473,7026
71396,7026
71396,7311
72621,7311
72621,7898
73695,7898
73695,8360
74844,8360
74844,9323
75689,9323
75689,9834
76813,9834
76813,10909
77552,10909
77552,11764
78426,11764
78426,12198
79619,12198
79619,12720
80766,12720
80766,13911
81353,13911
81353,14300
82639,14300
82639,15444
83238,15444
83238,15925
84480,15925
84480,17167
84951,17167
84951,18280
85528,18280
85528,19271
86225,19271
86225,20163
87036,20163
87036,20724
88286,20724
88286,21775
88917,21775
88917,22924
89395,22924
89395,24077
89844,24077
89844,24888
90823,24888
90823,25962
91392,25962
91392,27042
91944,27042
91944,28174
92391,28174
92391,28956
93550,28956
93550,30107
93978,30107
93978,31501
93820,31501
93820,32387
94861,32387
94861,33531
95288,33531
95288,34727
95560,34727
95560,35758
96349,35758
96349,37174
95847,37174
95847,38217
96640,38217
96640,39523
96391,39523
96391,40646
96922,40646
96922,41796
97381,41796
97381,43019
97440,43019
97440,44222
97609,44222
97609,45404
98016,45404
98016,46605
98352,46605
98352,47838
98266,47838
98266,49062
98278,49062
98278,50283
"""

from bisect import bisect_right
from collections import defaultdict

def parse_input(text):
    pts=[]
    for line in text.strip().splitlines():
        line=line.strip()
        if not line or line.startswith('#'):
            continue
        x_str,y_str=line.split(',',1)
        pts.append((int(x_str.strip()),int(y_str.strip())))
    return pts

pts = parse_input(data)
n = len(pts)
if n == 0:
    print(0)
    raise SystemExit

# sets for red tiles and edge (line) tiles
red = set(pts)
edge = set()

# build vertical edges list for scanline intersections
vertical_edges = []  # tuples (x, ymin, ymax) with ymin < ymax

for i in range(n):
    x1,y1 = pts[i]
    x2,y2 = pts[(i+1) % n]
    if x1 == x2:
        ymin = min(y1,y2)
        ymax = max(y1,y2)
        vertical_edges.append((x1, ymin, ymax))
        # mark the vertical edge tiles (inclusive)
        for yy in range(ymin, ymax+1):
            edge.add((x1, yy))
    elif y1 == y2:
        xmin = min(x1,x2)
        xmax = max(x1,x2)
        # mark the horizontal edge tiles (inclusive)
        for xx in range(xmin, xmax+1):
            edge.add((xx, y1))
    else:
        # according to puzzle, adjacent points are always same row or column
        raise ValueError("Input adjacent points not axis-aligned")

min_y = min(y for _,y in pts)
max_y = max(y for _,y in pts)

# Precompute for each integer row y the interior x-intervals (inclusive)
# We consider horizontal scanline at y+0.5; a vertical edge (x,ymin..ymax) intersects that
# scanline iff ymin <= y < ymax. For intersections we collect the x's and pair them.
rows_intervals = {}  # y -> list of (x_start, x_end) inclusive, merged and sorted

for y in range(min_y, max_y):
    xs = []
    for x, ymin, ymax in vertical_edges:
        if ymin <= y < ymax:
            xs.append(x)
    if not xs:
        continue
    xs.sort()
    intervals = []
    # pair intersections; interior x tiles satisfy x_i <= x < x_{i+1} -> integer x in [x_i, x_{i+1}-1]
    for k in range(0, len(xs)-1, 2):
        a = xs[k]
        b = xs[k+1]
        if a <= b-1:
            intervals.append((a, b-1))
    if not intervals:
        continue
    # merge intervals (defensive)
    merged = []
    cur_s, cur_e = intervals[0]
    for s,e in intervals[1:]:
        if s <= cur_e+1:
            if e > cur_e:
                cur_e = e
        else:
            merged.append((cur_s, cur_e))
            cur_s, cur_e = s, e
    merged.append((cur_s, cur_e))
    rows_intervals[y] = merged

# Helper: check if for a given row y the entire x-range [xs, xe] is allowed (green or red)
def row_covers(y, xs, xe):
    # if row has precomputed interior intervals
    if y in rows_intervals:
        intervals = rows_intervals[y]
        # binary search for interval that might contain xs
        lo = 0
        hi = len(intervals)
        # find rightmost interval with start <= xs
        idx = bisect_right(intervals, (xs, 10**18)) - 1
        if idx >= 0:
            s,e = intervals[idx]
            if s <= xs and e >= xe:
                return True
        # maybe xs lies on an edge or red tiles cover continuous span (rare) -> fallback to checking each x
    # fallback: small-width direct check (cover by edge or red)
    # to avoid huge loops, if width is very large and we don't have interval data, return False
    width = xe - xs + 1
    if width > 5000:
        return False
    for xx in range(xs, xe+1):
        if (xx, y) in red or (xx, y) in edge:
            continue
        # also check interior intervals (if any) that might include this xx
        if y in rows_intervals:
            covered = False
            for s,e in rows_intervals[y]:
                if s <= xx <= e:
                    covered = True
                    break
            if covered:
                continue
        return False
    return True

# iterate over all unordered pairs of red tiles as opposite corners
reds = list(red)
m = len(reds)
max_area = 0

for i in range(m):
    x1,y1 = reds[i]
    for j in range(i+1, m):
        x2,y2 = reds[j]
        if x1 == x2 or y1 == y2:
            continue
        xs = min(x1,x2)
        xe = max(x1,x2)
        ys = min(y1,y2)
        ye = max(y1,y2)
        # quick area upper bound check
        area = (xe - xs + 1) * (ye - ys + 1)
        if area <= max_area:
            continue
        ok = True
        # check each scan row in rectangle (use rows_intervals which were computed for y in [min_y, max_y-1])
        for y in range(ys, ye+1):
            if not row_covers(y, xs, xe):
                ok = False
                break
        if ok and area > max_area:
            max_area = area

print(max_area)
